from collections.abc import Iterator
import json
from pathlib import Path
from bson import ObjectId
from pydantic import BaseModel
from electronic_inv_sys.contracts.models import (
    ExistingInventoryItem,
    NewInventoryItem,
)
from electronic_inv_sys.contracts.repos import (
    DuplicateDigiKeyPartNumberError,
    InventoryRepository,
)


class InventoryItems(BaseModel):
    items: dict[ObjectId, ExistingInventoryItem]


class JsonFileRepository(InventoryRepository):

    def __init__(self, path: Path | str = "inventory.json"):
        super().__init__()
        self.__path = Path(path)
        with self.__path.open() as f:
            d = json.load(f)
        self.__data: InventoryItems = InventoryItems.model_validate(d)

    def __serialize(self):
        with self.__path.open("w") as f:
            json.dump(
                {str(k): v.model_dump_json() for k, v in self.__data.items.items()}, f
            )

    def __getitem__(self, key: ObjectId) -> ExistingInventoryItem:
        return self.__data.items[key]

    def __iter__(self) -> Iterator[ObjectId]:
        return iter(self.__data.items)

    def __len__(self) -> int:
        return len(self.__data.items)

    def add_new(self, item: NewInventoryItem) -> ObjectId:
        new_id = ObjectId()
        if new_id in self.__data.items:
            raise RuntimeError(f"Generated the same ID twice: {new_id}")

        if item.digikey_part_number is not None:
            possible_match = self.get_item_by_digikey_part_number(
                item.digikey_part_number
            )

            if possible_match is not None:
                raise DuplicateDigiKeyPartNumberError(possible_match.id, new_id)

        self.__data.items[new_id] = ExistingInventoryItem.from_parent(item, new_id)
        self.__serialize()
        return new_id

    def text_search(
        self, query: str, max_results: int | None = None
    ) -> list[ExistingInventoryItem]:
        raise NotImplementedError()

    def __setitem__(self, key: ObjectId, value: ExistingInventoryItem) -> None:
        assert key == value.id, f"Key {key} does not match item ID {value.id}"

        if value.digikey_part_number is not None:
            possible_match = self.get_item_by_digikey_part_number(
                value.digikey_part_number
            )

            if possible_match is not None and possible_match.id != value.id:
                raise DuplicateDigiKeyPartNumberError(possible_match.id, value.id)

        if value.id not in self.__data.items:
            raise KeyError(
                f"Item with ID {value.id} not found in inventory. Keys should be generated by the DB, not the user."
            )

        self.__data.items[value.id] = value
        self.__serialize()

    def __delitem__(self, key: ObjectId) -> None:
        raise NotImplementedError("Deletion is not supported for this repository")


if __name__ == "__main__":
    _ = JsonFileRepository()
