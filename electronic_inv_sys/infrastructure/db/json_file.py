import json
from pathlib import Path
from typing import Any, ItemsView, Iterator, KeysView, ValuesView
from bson import ObjectId
from electronic_inv_sys.contracts.models import (
    ExistingInventoryItem,
    NewInventoryItem,
)
from electronic_inv_sys.contracts.repos import (
    DuplicateDigiKeyPartNumberError,
    InventoryRepository,
)


class JsonFileRepository(InventoryRepository):

    def __init__(self, path: Path | str = "inventory.json"):
        super().__init__()
        self.__path = Path(path)
        self.__data: dict[ObjectId, ExistingInventoryItem] = {}
        with self.__path.open() as f:
            d = json.load(f)
            if not isinstance(d, dict):
                raise ValueError("Expected a JSON object at the root of the file")
            raw_id: Any
            raw_item: Any
            for raw_id, raw_item in d.items():
                _id = ObjectId(raw_id)
                if not isinstance(raw_item, dict):
                    raise ValueError("Expected a JSON object for each item")
                item = ExistingInventoryItem(**raw_item)  # type: ignore
                self.__data[_id] = item

    def __serialize(self):
        with self.__path.open("w") as f:
            json.dump({str(k): v.model_dump_json() for k, v in self.__data.items()}, f)

    def __getitem__(self, key: ObjectId) -> ExistingInventoryItem:
        return self.__data[key]

    def __iter__(self) -> Iterator[ObjectId]:
        return iter(self.__data)

    def __len__(self) -> int:
        return len(self.__data)

    def set_existing_item(self, item: ExistingInventoryItem) -> None:
        if item.digikey_part_number is not None:
            possible_match = self.get_item_by_digikey_part_number(
                item.digikey_part_number
            )

            if possible_match is not None and possible_match.id != item.id:
                raise DuplicateDigiKeyPartNumberError(possible_match.id, item.id)

        if item.id not in self.__data:
            raise KeyError(
                f"Item with ID {item.id} not found in inventory. Keys should be generated by the DB, not the user."
            )

        self.__data[item.id] = item
        self.__serialize()

    def add_new_item(self, item: NewInventoryItem) -> ObjectId:
        new_id = ObjectId()
        if new_id in self.__data:
            raise RuntimeError(f"Generated the same ID twice: {new_id}")

        if item.digikey_part_number is not None:
            possible_match = self.get_item_by_digikey_part_number(
                item.digikey_part_number
            )

            if possible_match is not None:
                raise DuplicateDigiKeyPartNumberError(possible_match.id, new_id)

        self.__data[new_id] = ExistingInventoryItem.from_parent(item, new_id)
        self.__serialize()
        return new_id

    def keys(self) -> KeysView[ObjectId]:
        return self.__data.keys()

    def items(self) -> ItemsView[ObjectId, ExistingInventoryItem]:
        return self.__data.items()

    def values(self) -> ValuesView[ExistingInventoryItem]:
        return self.__data.values()

    def text_search(self, query: str) -> list[ExistingInventoryItem]:
        raise NotImplementedError()


if __name__ == "__main__":
    JsonFileRepository()
