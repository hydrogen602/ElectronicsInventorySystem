from typing import ItemsView, Iterator, KeysView, ValuesView
from bson import ObjectId
from electronic_inv_sys.contracts.models import (
    ExistingInventoryItem,
    NewInventoryItem,
)
from electronic_inv_sys.contracts.repos import (
    DuplicateDigiKeyPartNumberError,
    InventoryRepository,
)


class InMemoryRepository(InventoryRepository):

    def __init__(self, data: dict[ObjectId, ExistingInventoryItem] | None = None):
        super().__init__()
        self.__data: dict[ObjectId, ExistingInventoryItem] = data or {}

    def __getitem__(self, key: ObjectId) -> ExistingInventoryItem:
        return self.__data[key]

    def __iter__(self) -> Iterator[ObjectId]:
        return iter(self.__data)

    def __len__(self) -> int:
        return len(self.__data)

    def set_existing_item(self, item: ExistingInventoryItem) -> None:
        if item.digikey_part_number is not None:
            possible_match = self.get_item_by_digikey_part_number(
                item.digikey_part_number
            )

            if possible_match is not None and possible_match.id != item.id:
                raise DuplicateDigiKeyPartNumberError(possible_match.id, item.id)

        if item.id not in self.__data:
            raise KeyError(
                f"Item with ID {item.id} not found in inventory. Keys should be generated by the DB, not the user."
            )

        self.__data[item.id] = item

    def add_new_item(self, item: NewInventoryItem) -> ObjectId:
        new_id = ObjectId()
        if new_id in self.__data:
            raise RuntimeError(f"Generated the same ID twice: {new_id}")

        if item.digikey_part_number is not None:
            possible_match = self.get_item_by_digikey_part_number(
                item.digikey_part_number
            )

            if possible_match is not None:
                raise DuplicateDigiKeyPartNumberError(possible_match.id, new_id)

        self.__data[new_id] = ExistingInventoryItem.from_parent(item, new_id)
        return new_id

    def keys(self) -> KeysView[ObjectId]:
        return self.__data.keys()

    def items(self) -> ItemsView[ObjectId, ExistingInventoryItem]:
        return self.__data.items()

    def values(self) -> ValuesView[ExistingInventoryItem]:
        return self.__data.values()

    def text_search(
        self, query: str, max_results: int | None = None
    ) -> list[ExistingInventoryItem]:
        raise NotImplementedError()


if __name__ == "__main__":
    InMemoryRepository()
