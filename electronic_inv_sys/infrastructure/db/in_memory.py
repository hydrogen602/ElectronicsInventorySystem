from typing import ItemsView, Iterator, KeysView, ValuesView
from bson import ObjectId
from electronic_inv_sys.contracts.models import (
    ExistingBom,
    ExistingInventoryItem,
    NewBom,
    NewInventoryItem,
)
from electronic_inv_sys.contracts.repos import (
    BomRepository,
    DuplicateDigiKeyPartNumberError,
    InventoryRepository,
)


class InMemoryBomRepository(BomRepository):
    def __init__(self, data: dict[ObjectId, ExistingBom] | None = None):
        self.__data: dict[ObjectId, ExistingBom] = data or {}

    def __getitem__(self, key: ObjectId) -> ExistingBom:
        return self.__data[key]

    def __iter__(self) -> Iterator[ObjectId]:
        return iter(self.__data)

    def __len__(self) -> int:
        return len(self.__data)

    def __setitem__(self, key: ObjectId, item: ExistingBom) -> None:
        assert key == item.id, f"Key {key} does not match item ID {item.id}"
        self.__data[key] = item

    def __delitem__(self, key: ObjectId) -> None:
        raise NotImplementedError("Deletion is not supported for this repository")

    def add_new(self, item: NewBom) -> ObjectId:
        new_id = ObjectId()
        if new_id in self.__data:
            raise RuntimeError(f"Generated the same ID twice: {new_id}")
        self.__data[new_id] = ExistingBom.from_parent(item, new_id)
        return new_id


class InMemoryRepository(InventoryRepository):

    def __init__(self, data: dict[ObjectId, ExistingInventoryItem] | None = None):
        super().__init__()
        self.__data: dict[ObjectId, ExistingInventoryItem] = data or {}

    def __getitem__(self, key: ObjectId) -> ExistingInventoryItem:
        return self.__data[key]

    def __iter__(self) -> Iterator[ObjectId]:
        return iter(self.__data)

    def __len__(self) -> int:
        return len(self.__data)

    def __setitem__(self, key: ObjectId, item: ExistingInventoryItem) -> None:
        assert key == item.id, f"Key {key} does not match item ID {item.id}"
        if item.digikey_part_number is not None:
            possible_match = self.get_item_by_digikey_part_number(
                item.digikey_part_number
            )

            if possible_match is not None and possible_match.id != item.id:
                raise DuplicateDigiKeyPartNumberError(possible_match.id, item.id)

        if item.id not in self.__data:
            raise KeyError(
                f"Item with ID {item.id} not found in inventory. Keys should be generated by the DB, not the user."
            )

        self.__data[item.id] = item

    def __delitem__(self, key: ObjectId) -> None:
        raise NotImplementedError("Deletion is not supported for this repository")

    def set_existing_item(self, item: ExistingInventoryItem) -> None:
        if item.digikey_part_number is not None:
            possible_match = self.get_item_by_digikey_part_number(
                item.digikey_part_number
            )

            if possible_match is not None and possible_match.id != item.id:
                raise DuplicateDigiKeyPartNumberError(possible_match.id, item.id)

        if item.id not in self.__data:
            raise KeyError(
                f"Item with ID {item.id} not found in inventory. Keys should be generated by the DB, not the user."
            )

        self.__data[item.id] = item

    def add_new(self, item: NewInventoryItem) -> ObjectId:
        new_id = ObjectId()
        if new_id in self.__data:
            raise RuntimeError(f"Generated the same ID twice: {new_id}")

        if item.digikey_part_number is not None:
            possible_match = self.get_item_by_digikey_part_number(
                item.digikey_part_number
            )

            if possible_match is not None:
                raise DuplicateDigiKeyPartNumberError(possible_match.id, new_id)

        self.__data[new_id] = ExistingInventoryItem.from_parent(item, new_id)
        return new_id

    def keys(self) -> KeysView[ObjectId]:
        return self.__data.keys()

    def items(self) -> ItemsView[ObjectId, ExistingInventoryItem]:
        return self.__data.items()

    def values(self) -> ValuesView[ExistingInventoryItem]:
        return self.__data.values()

    def text_search(
        self, query: str, max_results: int | None = None
    ) -> list[ExistingInventoryItem]:
        raise NotImplementedError()


if __name__ == "__main__":
    InMemoryRepository()
