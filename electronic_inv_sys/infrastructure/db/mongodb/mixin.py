from __future__ import annotations

from abc import ABC
from collections.abc import ItemsView, Iterator, KeysView, ValuesView
from typing import Any
from bson import ObjectId
from pydantic import BaseModel
from automapper import Mapper  # pyright: ignore[reportMissingTypeStubs]
from pymongo.synchronous.collection import (
    Collection,
)

from electronic_inv_sys.contracts.models import (
    WithId,
)


class RepoMixin[N, E: WithId, DB_N: BaseModel, DB_E: WithId](ABC):
    def __init__(
        self,
        collection: Collection[Any],
        mapper: Mapper,
        db_existing_cls: type[DB_E],
        **kwargs: Any,
    ) -> None:
        self._collection = collection
        self._mapper = mapper
        self._db_existing_cls = db_existing_cls
        super().__init__(**kwargs)

    def _db_map_to_contract_existing(self, item: DB_E) -> E:
        """
        Map a database item to a contract item. Override to customize the mapping.
        """
        return self._mapper.map(item)

    def _contract_map_to_db_existing(self, item: E) -> DB_E:
        """
        Map a contract item to a database item. Override to customize the mapping.
        """
        return self._mapper.map(item)

    def _contract_map_to_db_new(self, item: N) -> DB_N:
        """
        Map a contract item to a database item. Override to customize the mapping.
        """
        return self._mapper.map(item)

    def _item_extra_validation(self, item: DB_E | DB_N) -> None:
        pass

    def __getitem__(self, key: ObjectId) -> E:
        x = self._collection.find_one({"_id": key})
        if x is None:
            raise KeyError(f"No item with ID {key} found in repository")
        parsed = self._db_existing_cls.model_validate(x)
        return self._db_map_to_contract_existing(parsed)

    def __setitem__(self, key: ObjectId, value: E) -> None:
        """Update an existing BOM in the repository."""
        db_item: DB_E = self._contract_map_to_db_existing(value)
        assert key == db_item.id, f"Key {key} does not match item ID {db_item.id}"

        self._item_extra_validation(db_item)

        if self._collection.find_one({"_id": key}) is None:
            raise KeyError(
                f"Item with ID {key} not found. Keys should be generated by the DB, not the user."
            )

        # we need the id field to show up as _id for MongoDB
        result = self._collection.replace_one(
            {"_id": key}, db_item.model_dump(by_alias=True)
        )
        if result.matched_count != 1:
            raise RuntimeError(
                f"Item with ID {key} not found in repository - but we just checked!"
            )

    def __delitem__(self, key: ObjectId) -> None:
        raise NotImplementedError("Deletion is not supported for this repository")

    def __iter__(self) -> Iterator[ObjectId]:
        return iter(self._collection.find({}, {"_id": 1}))

    def __len__(self) -> int:
        return self._collection.count_documents({})

    def add_new(self, item: N) -> ObjectId:
        """Add a new item to the repository."""
        db_item: DB_N = self._contract_map_to_db_new(item)

        self._item_extra_validation(db_item)

        result = self._collection.insert_one(db_item.model_dump(by_alias=True))
        return result.inserted_id

    def keys(self) -> KeysView[ObjectId]:
        return set(e["_id"] for e in self._collection.find({}, {"_id": 1}))  # type: ignore

    def values(self) -> ValuesView[E]:
        result = self._collection.find({})
        output: list[E] = [
            self._db_map_to_contract_existing(self._db_existing_cls.model_validate(x))
            for x in result
        ]
        return output  # type: ignore

    def items(self) -> ItemsView[ObjectId, E]:
        result = self._collection.find({})
        return (
            {
                (
                    item := self._db_existing_cls.model_validate(x)
                ).id: self._db_map_to_contract_existing(item)
                for x in result
            }
        ).items()
